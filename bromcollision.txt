void Entity::DoPhyiscsLogic(){
	if (this->Force.X != 0 && this->CheckCollisionX(this->Force.X) != 0) this->Force.X = 0;
	if (this->Force.Y != 0 && this->CheckCollisionY(this->Force.Y) != 0) this->Force.Y = 0;

	// I AM BELOW THE LAW
	this->Force.Z -= 0.02;

	double left = this->Force.Z;
	while (left != 0) {
		double curdo = left > 0 ? (left < 1 ? left : 1) : (left < -1 ? -1 : left);

		Vector hitpos = this->CheckCollisionZ(curdo);
		if (hitpos != 0) {
			CollisionBox bb = BlockData::GetCollisionBox(this->World->GetBlock(hitpos));
			bb += hitpos;

			if (this->Force.Z > 0) this->Location.Z = bb.Min.Z - this->BoundingBox.Z;
			else this->Location.Z = bb.Max.Z;

			this->Force.Z = 0;
			break;
		}

		left -= curdo;
	}

	this->Location += this->Force;
	if (this->CheckCollisionZ(-0.1f) != 0) {
		this->Force.X *= 0.9f;
		this->Force.Y *= 0.9f;
	}
}

Vector Entity::CheckCollisionX(double m){
	Vector np = this->Location;
	np.X += m;

	int cfx = (int)np.X;
	int cfy = (int)np.Y;
	int cfz = (int)np.Z;
	int fz = (int)ceil(this->BoundingBox.Z);
	CollisionBox cbox = CollisionBox(np, np + this->BoundingBox);

	int tx = (int)ceil(cfx + m);

	for (int ay = -1; ay <= 1; ay++) {
		for (int az = 0; az < fz; az++) {
			short bid = this->World->GetBlockNoLoad(tx, cfy + ay, cfz + az);
			if (bid == 0 || !BlockData::GetHasCollision(bid))
				continue;

			Vector bo = Vector(tx, cfy + ay, cfz + az);
			CollisionBox bb = BlockData::GetCollisionBox(bid);
			bb += bo;

			if (cbox.Intersects(bb)) {
				return bo;
			}
		}
	}

	return Vector();
}

Vector Entity::CheckCollisionY(double m){
	Vector np = this->Location;
	np.Y += m;

	int cfx = (int)np.X;
	int cfy = (int)np.Y;
	int cfz = (int)np.Z;
	int fz = (int)ceil(this->BoundingBox.Z);
	CollisionBox cbox = CollisionBox(np, np + this->BoundingBox);

	int ty = (int)ceil(cfy + m);

	for (int ax = -1; ax <= 1; ax++) {
		for (int az = 0; az < fz; az++) {
			short bid = this->World->GetBlockNoLoad(cfx + ax, ty, cfz + az);
			if (bid == 0 || !BlockData::GetHasCollision(bid))
				continue;

			Vector bo = Vector(cfx + ax, ty, cfz + az);
			CollisionBox bb = BlockData::GetCollisionBox(bid);
			bb += bo;

			if (cbox.Intersects(bb)) {
				return bo;
			}
		}
	}

	return Vector();
}

Vector Entity::CheckCollisionZ(double m){
	Vector np = this->Location;
	np.Z += m;

	int cfx = (int)np.X;
	int cfy = (int)np.Y;
	int cfz = (int)np.Z;
	int fz = (int)ceil(this->BoundingBox.Z);
	CollisionBox cbox = CollisionBox(np, np + this->BoundingBox);

	int tz = (int)ceil(cfz + m);
	if (m > 0)
		tz += 1;

	for (int ax = -1; ax <= 1; ax++) {
		for (int ay = -1; ay <= 1; ay++) {
			short bid = this->World->GetBlockNoLoad(cfx + ax, cfy + ay, tz);
			if (bid == 0 || !BlockData::GetHasCollision(bid))
				continue;

			Vector bo = Vector(cfx + ax, cfy + ay, tz);
			CollisionBox bb = BlockData::GetCollisionBox(bid);
			bb += bo;

			if (cbox.Intersects(bb)) {
				return bo;
			}
		}
	}

	return Vector();
}